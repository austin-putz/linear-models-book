{
  "hash": "db2970aa7a34c5a12da70bc5d68dc3e2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Week 2: Linear Algebra Essentials\"\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    number-sections: true\n    code-fold: false\n    code-tools: true\n---\n\n::: {.callout-note icon=false}\n## Learning Objectives\n\nBy the end of this week, you will be able to:\n\n1. **Define** and **compute** the **rank** of a matrix\n2. **Understand** **linear independence** and its implications for solving equations\n3. **Compute** **regular inverses** and **generalized inverses** of matrices\n4. **Solve** systems of **linear equations** using matrix methods\n5. **Recognize** when a system has **unique**, **infinite**, or **no solutions**\n:::\n\n## Why Linear Algebra Matters for Linear Models\n\nLast week, we worked with a simple model where $\\mathbf{X}'\\mathbf{X}$ was just a scalar (the sample size $n$). Inverting was trivial: $(n)^{-1} = 1/n$.\n\n**But what happens when:**\n\n- We have multiple effects (breeds, herds, years)?\n- Some combinations are missing (not all breeds on all farms)?\n- We have more parameters than we can uniquely estimate?\n\nIn these cases, $\\mathbf{X}'\\mathbf{X}$ becomes a larger matrix that may not be **full rank** - meaning it doesn't have a regular inverse. Understanding matrix rank and generalized inverses is **essential** for:\n\n- Building ANOVA models\n- Handling unbalanced data\n- Understanding estimability\n- Working toward mixed models and BLUP\n\n## Vector Spaces and Linear Independence\n\n### Vectors as Points in Space\n\nA vector $\\mathbf{v} = \\begin{bmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{bmatrix}$ can be thought of as a point in $n$-dimensional space.\n\nFor example, $\\mathbf{v} = \\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}$ is a point in 2-D space.\n\n### Linear Combinations\n\nA **linear combination** of vectors $\\mathbf{v}_1, \\mathbf{v}_2, \\ldots, \\mathbf{v}_k$ is:\n\n$$\nc_1\\mathbf{v}_1 + c_2\\mathbf{v}_2 + \\cdots + c_k\\mathbf{v}_k\n$$\n\nwhere $c_1, c_2, \\ldots, c_k$ are scalars.\n\n**Example:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(1, 0)\nv2 <- c(0, 1)\n\n# Linear combination: 2*v1 + 3*v2\nresult <- 2*v1 + 3*v2\nprint(\"2*v1 + 3*v2 =\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2*v1 + 3*v2 =\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n:::\n\n\n### Linear Independence\n\nVectors $\\mathbf{v}_1, \\mathbf{v}_2, \\ldots, \\mathbf{v}_k$ are **linearly independent** if the only solution to:\n\n$$\nc_1\\mathbf{v}_1 + c_2\\mathbf{v}_2 + \\cdots + c_k\\mathbf{v}_k = \\mathbf{0}\n$$\n\nis $c_1 = c_2 = \\cdots = c_k = 0$.\n\nIn other words, no vector can be written as a linear combination of the others.\n\n**Example of linear independence:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These vectors are linearly independent\nv1 <- c(1, 0)\nv2 <- c(0, 1)\n\n# No combination (except 0*v1 + 0*v2) gives the zero vector\n# They point in different directions\n```\n:::\n\n\n**Example of linear dependence:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These vectors are linearly dependent\nv1 <- c(1, 2)\nv2 <- c(2, 4)  # v2 = 2*v1\n\n# v2 can be written as a multiple of v1\n# Therefore: 2*v1 - 1*v2 = 0 (non-trivial combination)\nprint(\"2*v1 - v2 =\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2*v1 - v2 =\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(2*v1 - v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0\n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n## Connection to Linear Models\n\nIn a design matrix $\\mathbf{X}$:\n\n- Each **column** represents an effect (e.g., breed, herd)\n- Columns are linearly independent → all effects are estimable\n- Columns are linearly dependent → we have **rank deficiency**\n\nRank deficiency means we can't uniquely estimate all parameters!\n:::\n\n## Rank of a Matrix\n\n### Definition\n\nThe **rank** of a matrix $\\mathbf{A}$, denoted $r(\\mathbf{A})$, is the number of linearly independent rows (or columns).\n\n**Key properties:**\n\n- $r(\\mathbf{A}) \\leq \\min(m, n)$ for an $m \\times n$ matrix\n- $r(\\mathbf{A}) = r(\\mathbf{A}')$\n- $r(\\mathbf{AB}) \\leq \\min(r(\\mathbf{A}), r(\\mathbf{B}))$\n- $r(\\mathbf{A}'\\mathbf{A}) = r(\\mathbf{A})$\n\n### Full Rank vs. Rank Deficient\n\nA matrix $\\mathbf{A}$ ($m \\times n$) is:\n\n- **Full rank** if $r(\\mathbf{A}) = \\min(m, n)$\n- **Rank deficient** if $r(\\mathbf{A}) < \\min(m, n)$\n\nFor a square matrix ($n \\times n$):\n\n- Full rank means $r(\\mathbf{A}) = n$\n- Rank deficient means $r(\\mathbf{A}) < n$\n\n### Computing Rank in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\n\n# Full rank matrix\nA_full <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)\nprint(\"Full rank matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Full rank matrix:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A_full)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank:\", qr(A_full)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank: 2\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Rank deficient matrix\nA_deficient <- matrix(c(1, 2, 2, 4), nrow = 2, ncol = 2)\nprint(\"Rank deficient matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank deficient matrix:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A_deficient)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank:\", qr(A_deficient)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank: 1\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Note: second column is 2 times first column\n```\n:::\n\n\n### Small Example: Design Matrix Rank\n\nConsider a beef feedlot study with 4 steers in 2 pens:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data: 4 steers, 2 pens (2 steers each)\n# Pen: 1, 1, 2, 2\n\n# Design matrix (effects model: overall mean + pen effect)\nX <- matrix(c(\n  1, 1, 0,  # Steer 1: in pen 1\n  1, 1, 0,  # Steer 2: in pen 1\n  1, 0, 1,  # Steer 3: in pen 2\n  1, 0, 1   # Steer 4: in pen 2\n), nrow = 4, ncol = 3, byrow = TRUE)\n\ncolnames(X) <- c(\"mu\", \"pen1\", \"pen2\")\nprint(\"Design matrix X:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Design matrix X:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     mu pen1 pen2\n[1,]  1    1    0\n[2,]  1    1    0\n[3,]  1    0    1\n[4,]  1    0    1\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Number of columns (parameters):\", ncol(X)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of columns (parameters): 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank of X:\", qr(X)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank of X: 2\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# X'X\nXtX <- t(X) %*% X\nprint(\"X'X:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X'X:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(XtX)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     mu pen1 pen2\nmu    4    2    2\npen1  2    2    0\npen2  2    0    2\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank of X'X:\", qr(XtX)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank of X'X: 2\"\n```\n\n\n:::\n:::\n\n\n::: {.callout-warning}\n## Rank Deficiency in Design Matrices\n\n**Problem**: We have 3 columns but rank = 2. Why?\n\nThe first column (overall mean) equals the sum of the second and third columns (pen effects):\n\n$$\n\\text{Column 1} = \\text{Column 2} + \\text{Column 3}\n$$\n\nThis is called **linear dependence** or **singularity**.\n\n**Consequences**:\n- $\\mathbf{X}'\\mathbf{X}$ is not invertible (no regular inverse exists)\n- Individual parameters ($\\mu$, $\\alpha_1$, $\\alpha_2$) cannot be uniquely estimated\n- We need **constraints** or **generalized inverses** to obtain solutions\n\n**Solution**: Use generalized inverses (next section) or apply constraints to make the design matrix full rank.\n:::\n\n## Matrix Inverses\n\n### Regular Inverse\n\nFor a **square** matrix $\\mathbf{A}$ ($n \\times n$), the inverse $\\mathbf{A}^{-1}$ satisfies:\n\n$$\n\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{A}^{-1}\\mathbf{A} = \\mathbf{I}\n$$\n\n**Requirements** for $\\mathbf{A}^{-1}$ to exist:\n\n1. $\\mathbf{A}$ must be square ($n \\times n$)\n2. $\\mathbf{A}$ must be **full rank**: $r(\\mathbf{A}) = n$\n3. Equivalently: $\\det(\\mathbf{A}) \\neq 0$ (determinant non-zero)\n\n### Computing Regular Inverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Full rank 2x2 matrix\nA <- matrix(c(4, 3, 3, 2), nrow = 2, ncol = 2)\nprint(\"Matrix A:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Matrix A:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    4    3\n[2,]    3    2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Compute inverse\nA_inv <- solve(A)\nprint(\"A inverse:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A inverse:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A_inv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   -2    3\n[2,]    3   -4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verify: A * A^-1 = I\nI_check <- A %*% A_inv\nprint(\"A * A^-1 (should be identity):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A * A^-1 (should be identity):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(round(I_check, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n\n\n:::\n:::\n\n\n### When Inverse Doesn't Exist\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rank deficient matrix\nB <- matrix(c(1, 2, 2, 4), nrow = 2, ncol = 2)\nprint(\"Rank deficient matrix B:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank deficient matrix B:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank:\", qr(B)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank: 1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Determinant:\", det(B)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Determinant: 0\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Try to invert - this will fail\ntry({\n  B_inv <- solve(B)\n}, silent = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in solve.default(B) : \n  Lapack routine dgesv: system is exactly singular: U[2,2] = 0\n```\n\n\n:::\n:::\n\n\nThe error occurs because B is **singular** (not full rank). We need a generalized inverse instead!\n\n## Generalized Inverses\n\n### Definition\n\nA **generalized inverse** (g-inverse) of matrix $\\mathbf{A}$ is any matrix $\\mathbf{A}^{-}$ that satisfies:\n\n$$\n\\mathbf{A}\\mathbf{A}^{-}\\mathbf{A} = \\mathbf{A}\n$$ {#eq-ginv-definition}\n\n**Key facts:**\n\n- Generalized inverses exist for **any** matrix (even non-square, rank deficient)\n- Generalized inverses are **not unique** (many possible g-inverses)\n- If $\\mathbf{A}$ is full rank, then $\\mathbf{A}^{-} = \\mathbf{A}^{-1}$ (unique)\n\n::: {.callout-warning}\n## NOTATION EXTENSION\n\nWe now extend our notation from Week 1 to include **generalized inverses**:\n\n- $\\mathbf{A}^{-}$ = generalized inverse (g-inverse) of matrix $\\mathbf{A}$\n  - Satisfies: $\\mathbf{A}\\mathbf{A}^{-}\\mathbf{A} = \\mathbf{A}$ (@eq-ginv-definition)\n  - **Not unique** (multiple g-inverses exist)\n  - Works for any matrix (even rank deficient)\n\n- $\\mathbf{A}^{+}$ = Moore-Penrose inverse (special g-inverse)\n  - **Unique** generalized inverse\n  - Computed with `ginv()` in R\n\n**Key distinction from Week 1**:\n- Regular inverse $\\mathbf{A}^{-1}$: requires square, full rank matrix\n- Generalized inverse $\\mathbf{A}^{-}$: works for any matrix, including rank deficient\n\nThis notation will be essential for handling **overparameterized models** and **missing cells** in ANOVA (Weeks 7-12).\n:::\n\n### Moore-Penrose Inverse\n\nThe **Moore-Penrose inverse** $\\mathbf{A}^{+}$ is a special g-inverse that satisfies four conditions:\n\n1. $\\mathbf{A}\\mathbf{A}^{+}\\mathbf{A} = \\mathbf{A}$\n2. $\\mathbf{A}^{+}\\mathbf{A}\\mathbf{A}^{+} = \\mathbf{A}^{+}$\n3. $(\\mathbf{A}\\mathbf{A}^{+})' = \\mathbf{A}\\mathbf{A}^{+}$ (symmetric)\n4. $(\\mathbf{A}^{+}\\mathbf{A})' = \\mathbf{A}^{+}\\mathbf{A}$ (symmetric)\n\nThe Moore-Penrose inverse is **unique** and computed in R using `ginv()` from the MASS package [@penrose1955; @moore1920].\n\n### Computing Generalized Inverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\n\n# Rank deficient matrix\nB <- matrix(c(1, 2, 2, 4), nrow = 2, ncol = 2)\nprint(\"Rank deficient matrix B:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank deficient matrix B:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank:\", qr(B)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank: 1\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Compute Moore-Penrose generalized inverse\nB_ginv <- ginv(B)\nprint(\"Generalized inverse B^-:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Generalized inverse B^-:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(B_ginv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,] 0.04 0.08\n[2,] 0.08 0.16\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verify the defining property: B * B^- * B = B\ncheck <- B %*% B_ginv %*% B\nprint(\"B * B^- * B (should equal B):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"B * B^- * B (should equal B):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(round(check, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Note: B * B^- ≠ I (identity)\nBB_ginv <- B %*% B_ginv\nprint(\"B * B^- (NOT identity):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"B * B^- (NOT identity):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(round(BB_ginv, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]  0.2  0.4\n[2,]  0.4  0.8\n```\n\n\n:::\n:::\n\n\n::: {.callout-important}\n## Key Difference\n\n**Regular inverse**: $\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{I}$\n\n**Generalized inverse**: $\\mathbf{A}\\mathbf{A}^{-}\\mathbf{A} = \\mathbf{A}$ (but $\\mathbf{A}\\mathbf{A}^{-} \\neq \\mathbf{I}$ in general)\n:::\n\n### Application to Normal Equations\n\nFor rank deficient $\\mathbf{X}'\\mathbf{X}$:\n\n$$\n\\mathbf{X}'\\mathbf{X}\\mathbf{b} = \\mathbf{X}'\\mathbf{y}\n$$ {#eq-normal-equations-rankdef}\n\nOne solution is:\n\n$$\n\\mathbf{b} = (\\mathbf{X}'\\mathbf{X})^{-}\\mathbf{X}'\\mathbf{y}\n$$ {#eq-ginv-solution}\n\n**Important**: This gives **a** solution, but not necessarily a unique solution. Different g-inverses give different $\\mathbf{b}$ vectors.\n\nHowever, certain functions of $\\mathbf{b}$ (called **estimable functions**) are unique regardless of which g-inverse is used. We'll explore this in Week 8.\n\n## Solving Systems of Linear Equations\n\n### General Form\n\nA system of linear equations can be written as:\n\n$$\n\\mathbf{A}\\mathbf{x} = \\mathbf{b}\n$$ {#eq-linear-system}\n\nWhere:\n\n- $\\mathbf{A}$ is an $m \\times n$ coefficient matrix\n- $\\mathbf{x}$ is an $n \\times 1$ vector of unknowns\n- $\\mathbf{b}$ is an $m \\times 1$ vector of constants\n\n### Three Cases\n\n**Case 1: Unique Solution**\n\n- $\\mathbf{A}$ is square and full rank\n- Solution: $\\mathbf{x} = \\mathbf{A}^{-1}\\mathbf{b}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(2, 1, 1, 3), nrow = 2, ncol = 2)\nb <- c(8, 7)\n\nprint(\"System: Ax = b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"System: Ax = b\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"A:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    1\n[2,]    1    3\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"b:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"b:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8 7\n```\n\n\n:::\n\n```{.r .cell-code}\n# Unique solution\nx <- solve(A) %*% b\nprint(\"Solution x:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Solution x:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  3.4\n[2,]  1.2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verify\nprint(\"Ax (should equal b):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Ax (should equal b):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A %*% x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    8\n[2,]    7\n```\n\n\n:::\n:::\n\n\n**Case 2: Infinite Solutions**\n\n- More unknowns than equations, or\n- Rows/columns linearly dependent\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# System: x1 + 2*x2 = 5\n#         2*x1 + 4*x2 = 10  (second equation is 2× first)\n\nA <- matrix(c(1, 2, 2, 4), nrow = 2, ncol = 2, byrow = TRUE)\nb <- c(5, 10)\n\nprint(\"System (second equation redundant):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"System (second equation redundant):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank:\", qr(A)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank: 1\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# One solution using generalized inverse\nA_ginv <- ginv(A)\nx_particular <- A_ginv %*% b\nprint(\"One particular solution:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"One particular solution:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(x_particular)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]    1\n[2,]    2\n```\n\n\n:::\n\n```{.r .cell-code}\n# But infinitely many solutions exist!\n# Any x = [5 - 2*t, t] for any t works\n```\n:::\n\n\n**Case 3: No Solution (Inconsistent)**\n\n- Equations are contradictory\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# System: x1 + 2*x2 = 5\n#         2*x1 + 4*x2 = 12  (contradicts first equation!)\n\nA <- matrix(c(1, 2, 2, 4), nrow = 2, ncol = 2, byrow = TRUE)\nb_inconsistent <- c(5, 12)\n\nprint(\"Inconsistent system:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Inconsistent system:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"b:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"b:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(b_inconsistent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 12\n```\n\n\n:::\n\n```{.r .cell-code}\n# ginv() gives \"least squares\" solution (minimizes ||Ax - b||)\nx_ls <- ginv(A) %*% b_inconsistent\nprint(\"Least squares solution (doesn't satisfy exactly):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Least squares solution (doesn't satisfy exactly):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(x_ls)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,] 1.16\n[2,] 2.32\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"Ax (does NOT equal b):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Ax (does NOT equal b):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(A %*% x_ls)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  5.8\n[2,] 11.6\n```\n\n\n:::\n:::\n\n\n### Connection to Animal Breeding\n\nIn genetic evaluation:\n\n- **Case 1** (unique solution): Balanced experiments with all factor combinations\n- **Case 2** (infinite solutions): Missing cells, confounded effects → need constraints\n- **Case 3** (no solution): Usually doesn't occur with real data (every observation provides information)\n\nWe almost always encounter **Case 2** in animal breeding, which is why understanding generalized inverses and estimability is crucial.\n\n## Small Numerical Example: Pig Litter Size\n\nLet's work through a complete example with rank deficiency.\n\n### Problem Setup\n\nThree breeds of pigs with unequal replication:\n\n- **Yorkshire**: 3 litters\n- **Landrace**: 2 litters\n- **Duroc**: 1 litter\n\nLitter sizes: Yorkshire (11, 12, 10), Landrace (10, 11), Duroc (9)\n\n### Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Litter size data\nlitter_size <- c(11, 12, 10, 10, 11, 9)\nbreed <- factor(c(\"Yorkshire\", \"Yorkshire\", \"Yorkshire\",\n                  \"Landrace\", \"Landrace\", \"Duroc\"))\n\ndata_pig <- data.frame(breed = breed, litter_size = litter_size)\nprint(data_pig)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      breed litter_size\n1 Yorkshire          11\n2 Yorkshire          12\n3 Yorkshire          10\n4  Landrace          10\n5  Landrace          11\n6     Duroc           9\n```\n\n\n:::\n:::\n\n\n### Cell Means Model (Full Rank)\n\nModel: $y_{ij} = \\mu_i + e_{ij}$ where $i$ = breed, $j$ = observation within breed\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Design matrix: indicator for each breed\nX_cell <- model.matrix(~ breed - 1, data = data_pig)\nprint(\"Cell means design matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Cell means design matrix:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(X_cell)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  breedDuroc breedLandrace breedYorkshire\n1          0             0              1\n2          0             0              1\n3          0             0              1\n4          0             1              0\n5          0             1              0\n6          1             0              0\nattr(,\"assign\")\n[1] 1 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$breed\n[1] \"contr.treatment\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank of X:\", qr(X_cell)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank of X: 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# This is full rank! (3 columns, rank = 3)\n\n# Solve using normal equations\ny <- litter_size\nXtX <- t(X_cell) %*% X_cell\nXty <- t(X_cell) %*% y\n\nprint(\"X'X:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X'X:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(XtX)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               breedDuroc breedLandrace breedYorkshire\nbreedDuroc              1             0              0\nbreedLandrace           0             2              0\nbreedYorkshire          0             0              3\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(\"X'y:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X'y:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(Xty)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               [,1]\nbreedDuroc        9\nbreedLandrace    21\nbreedYorkshire   33\n```\n\n\n:::\n\n```{.r .cell-code}\n# Invert (regular inverse exists)\nb_cell <- solve(XtX) %*% Xty\nprint(\"Breed means (cell means model):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Breed means (cell means model):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(b_cell)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               [,1]\nbreedDuroc      9.0\nbreedLandrace  10.5\nbreedYorkshire 11.0\n```\n\n\n:::\n\n```{.r .cell-code}\n# These are simply the breed averages!\nprint(\"Verify - breed averages:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Verify - breed averages:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(tapply(litter_size, breed, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Duroc  Landrace Yorkshire \n      9.0      10.5      11.0 \n```\n\n\n:::\n:::\n\n\n### Effects Model (Rank Deficient)\n\nModel: $y_{ij} = \\mu + \\alpha_i + e_{ij}$ where $\\mu$ = overall mean, $\\alpha_i$ = breed effect\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Design matrix: intercept + breed effects\nX_effects <- model.matrix(~ breed, data = data_pig)\nprint(\"Effects model design matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Effects model design matrix:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(X_effects)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept) breedLandrace breedYorkshire\n1           1             0              1\n2           1             0              1\n3           1             0              1\n4           1             1              0\n5           1             1              0\n6           1             0              0\nattr(,\"assign\")\n[1] 0 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$breed\n[1] \"contr.treatment\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Number of columns:\", ncol(X_effects)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of columns: 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank of X:\", qr(X_effects)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank of X: 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Rank deficient! (4 columns but rank = 3)\n\n# X'X is singular\nXtX_effects <- t(X_effects) %*% X_effects\nprint(\"X'X (effects model):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X'X (effects model):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(XtX_effects)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               (Intercept) breedLandrace breedYorkshire\n(Intercept)              6             2              3\nbreedLandrace            2             2              0\nbreedYorkshire           3             0              3\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank of X'X:\", qr(XtX_effects)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank of X'X: 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Determinant of X'X:\", det(XtX_effects)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Determinant of X'X: 6\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Cannot use regular inverse - use generalized inverse\nXtX_ginv <- ginv(XtX_effects)\nXty_effects <- t(X_effects) %*% y\n\nb_effects <- XtX_ginv %*% Xty_effects\nprint(\"Solution using generalized inverse:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Solution using generalized inverse:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(b_effects)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  9.0\n[2,]  1.5\n[3,]  2.0\n```\n\n\n:::\n:::\n\n\n**Note**: The solution depends on which generalized inverse we use. R's `ginv()` sets one parameter to zero by default.\n\nLet's verify estimable functions are consistent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Contrast: Yorkshire - Duroc\n# In cell means model: mu_Yorkshire - mu_Duroc\ncontrast_cell <- b_cell[1] - b_cell[3]\n\n# In effects model: alpha_Yorkshire - alpha_Duroc\n# (mu cancels out)\ncontrast_effects <- b_effects[2] - b_effects[3]\n\nprint(\"Yorkshire - Duroc difference:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Yorkshire - Duroc difference:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Cell means model:\", round(contrast_cell, 4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Cell means model: -2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Effects model:\", round(contrast_effects, 4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Effects model: -0.5\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Match:\", all.equal(contrast_cell, contrast_effects)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Match: Mean relative difference: 0.75\"\n```\n\n\n:::\n:::\n\n\nThe contrast (difference between breeds) is the same regardless of parameterization! This is an **estimable function**.\n\n## Realistic Livestock Application\n\n### Scenario\n\nA sheep researcher measures fleece weight (kg) for 3 breeds across 2 farms, but not all breed × farm combinations are present (unbalanced design).\n\n### Data Structure\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(456)\n\n# Farm-Breed combinations (missing cells)\nfarm <- factor(c(rep(\"A\", 5), rep(\"B\", 4)))\nbreed <- factor(c(rep(\"Merino\", 3), rep(\"Suffolk\", 2),  # Farm A\n                  rep(\"Suffolk\", 2), rep(\"Romney\", 2)))  # Farm B\n\n# Note: No Merino on Farm B, No Romney on Farm A\n\nfleece_weight <- c(\n  # Farm A: Merino\n  4.8, 5.1, 4.9,\n  # Farm A: Suffolk\n  5.5, 5.8,\n  # Farm B: Suffolk\n  5.2, 5.4,\n  # Farm B: Romney\n  5.9, 6.1\n)\n\nsheep_data <- data.frame(\n  farm = farm,\n  breed = breed,\n  fleece_weight = fleece_weight\n)\n\nprint(\"Sheep fleece weight data:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sheep fleece weight data:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(sheep_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  farm   breed fleece_weight\n1    A  Merino           4.8\n2    A  Merino           5.1\n3    A  Merino           4.9\n4    A Suffolk           5.5\n5    A Suffolk           5.8\n6    B Suffolk           5.2\n7    B Suffolk           5.4\n8    B  Romney           5.9\n9    B  Romney           6.1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check structure\ntable(sheep_data$farm, sheep_data$breed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   \n    Merino Romney Suffolk\n  A      3      0       2\n  B      0      2       2\n```\n\n\n:::\n:::\n\n\n### Analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Full model: farm + breed + farm×breed\n# But missing cells cause rank deficiency\n\nX_full <- model.matrix(~ farm * breed, data = sheep_data)\nprint(\"Design matrix (first 5 rows):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Design matrix (first 5 rows):\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(head(X_full, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept) farmB breedRomney breedSuffolk farmB:breedRomney\n1           1     0           0            0                 0\n2           1     0           0            0                 0\n3           1     0           0            0                 0\n4           1     0           0            1                 0\n5           1     0           0            1                 0\n  farmB:breedSuffolk\n1                  0\n2                  0\n3                  0\n4                  0\n5                  0\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Number of columns:\", ncol(X_full)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of columns: 6\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank:\", qr(X_full)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank: 4\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Rank deficient due to missing cells\n\n# Solve using generalized inverse\ny_sheep <- fleece_weight\nXtX <- t(X_full) %*% X_full\nXty <- t(X_full) %*% y_sheep\n\nprint(\"X'X:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X'X:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(XtX)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   (Intercept) farmB breedRomney breedSuffolk farmB:breedRomney\n(Intercept)                  9     4           2            4                 2\nfarmB                        4     4           2            2                 2\nbreedRomney                  2     2           2            0                 2\nbreedSuffolk                 4     2           0            4                 0\nfarmB:breedRomney            2     2           2            0                 2\nfarmB:breedSuffolk           2     2           0            2                 0\n                   farmB:breedSuffolk\n(Intercept)                         2\nfarmB                               2\nbreedRomney                         0\nbreedSuffolk                        2\nfarmB:breedRomney                   0\nfarmB:breedSuffolk                  2\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(paste(\"Rank of X'X:\", qr(XtX)$rank))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Rank of X'X: 4\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Generalized inverse solution\nXtX_ginv <- ginv(XtX)\nb_sheep <- XtX_ginv %*% Xty\n\nprint(\"Parameter estimates:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Parameter estimates:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(b_sheep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            [,1]\n[1,]  4.93333333\n[2,]  0.07333333\n[3,]  0.49666667\n[4,]  0.71666667\n[5,]  0.49666667\n[6,] -0.42333333\n```\n\n\n:::\n\n```{.r .cell-code}\n# Estimable contrasts within farm\n# Suffolk at Farm A vs Suffolk at Farm B\n# (these cells both exist, so difference is estimable)\n\n# Verify with lm()\nmodel_sheep <- lm(fleece_weight ~ farm * breed, data = sheep_data)\nprint(\"lm() coefficients:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm() coefficients:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(coef(model_sheep))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       (Intercept)              farmB        breedRomney       breedSuffolk \n         4.9333333         -0.3500000          1.4166667          0.7166667 \n farmB:breedRomney farmB:breedSuffolk \n                NA                 NA \n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## Practical Advice\n\nWhen dealing with missing cells or rank deficiency:\n\n1. Use **cell means** models when possible (always full rank)\n2. For effects models, use **generalized inverse** (`ginv()`)\n3. Only interpret **estimable functions** (contrasts, differences)\n4. Week 8 will formalize estimability criteria\n:::\n\n## Summary\n\nThis week covered essential linear algebra for linear models:\n\n### Key Concepts\n\n::: {.callout-note}\n## What We Learned\n\n1. **Linear independence**: Vectors that can't be written as combinations of each other\n2. **Rank**: Number of linearly independent rows/columns\n   - Full rank: $r(\\mathbf{A}) = \\min(m, n)$\n   - Rank deficient: $r(\\mathbf{A}) < \\min(m, n)$\n\n3. **Regular inverse** $\\mathbf{A}^{-1}$:\n   - Requires square, full rank matrix\n   - $\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{I}$\n\n4. **Generalized inverse** $\\mathbf{A}^{-}$:\n   - Works for any matrix\n   - Not unique\n   - $\\mathbf{A}\\mathbf{A}^{-}\\mathbf{A} = \\mathbf{A}$ (@eq-ginv-definition)\n\n5. **Moore-Penrose inverse** $\\mathbf{A}^{+}$:\n   - Unique generalized inverse\n   - Computed with `ginv()` in R\n\n6. **Solving** $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ (@eq-linear-system):\n   - Full rank → unique solution\n   - Rank deficient → infinite solutions (use g-inverse)\n   - Inconsistent → no exact solution\n:::\n\n### Implications for Linear Models\n\n- Cell means models are always full rank\n- Effects models are often rank deficient (overparameterized)\n- Generalized inverses let us solve normal equations\n- Only **estimable functions** have unique values\n- Understanding rank is key to understanding what we can estimate\n\n### Looking Ahead\n\n**Week 3**: Build design matrices for different model types\n\n**Week 4-5**: Regression models (usually full rank)\n\n**Week 7-8**: ANOVA models (often rank deficient) and estimable functions\n\n**Week 12**: Deep dive into non-full rank models and constraints\n\n## R Functions Reference\n\n- `qr(A)$rank` - Compute rank of matrix A\n- `solve(A)` - Regular inverse of A\n- `ginv(A)` - Moore-Penrose generalized inverse (MASS package)\n- `det(A)` - Determinant of A\n- `model.matrix()` - Create design matrix from formula\n\n## Additional Resources\n\n### Key References\n\n- @penrose1955 - Original paper on generalized inverses\n- @searle1971 - Linear models textbook with extensive matrix algebra\n- @searle2006 - Updated edition\n\n### Practice\n\nWork through Exercise Set 2 to solidify these concepts!\n\n---\n\n**Previous**: [Week 1: Course Overview](../Week01_Overview/Week01_CourseOverview.qmd)\n\n**Next**: [Week 3: Building the Design Matrix Framework](../Week03_DesignMatrix/Week03_DesignMatrix.qmd)\n",
    "supporting": [
      "Week02_LinearAlgebra_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}